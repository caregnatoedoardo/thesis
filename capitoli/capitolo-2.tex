% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Container VS Virtual Machine}
\label{cap:container-vm}
%**************************************************************

\intro{Introduzione al capitolo}\\
Nel presente capitolo si esporranno le principali differenze tra un'architettura basata su macchine virtuali ed un'altra basata invece su container.

%**************************************************************
\section{Differenze architetturali tra Container e VM}
La \textbf{virtualizzazione} è un insieme di software in grado di astrarre componenti \gls{hardware}, permettendo l'esecuzione, anche simultanea, di più \gls{sistemi operativi} su un singolo \gls{client}. Verso la fine degli anni '90, la virtualizzazione ha cominciato ad essere sempre più utilizzata in ambienti \textit{enterprise}, permettendo un aumento di scalabilità e flessibilità dell'infrastruttura informatica aziendale riducendone notevolmente i costi di gestione\footcite{fonte: https://www.vmware.com/it/solutions/virtualization.html}. I \textbf{vantaggi} legati all'utilizzo della virtualizzazione, nello specifico, tramite l'uso di una o più macchine virtuali, comportano una separazione tra il sistema operativo \gls{host} e \gls{guest}, fornendo una serie di accessi logici utilizzati da utenti esterni agli applicativi eseguiti in ogni macchina virtuale. \\
Oltre ad una esecuzione parallela, dal punto di vista dell' \textit{host}, di molteplici applicativi, un'architettura a VM è più facilmente \textbf{manutenibile}: una macchina virtuale infatti, può essere facilmente aggiornata, avviata o arrestata in base alle esigenze di carico (ex: \textit{load-balancing}) o aziendali.
La virtualizzazione, inoltre, aumenta l'\textbf{affidabilità} dell'intero sistema, in quanto garantisce l'\textbf{isolamento} di programmi e servizi i quali non andranno in conflitto tra di loro, contenendo, in aggiunta, il numero di server fisici presenti in \gls{datacenter} nel caso in cui molteplici macchine virtuali vengano eseguite su un singolo \textit{host}, con conseguente notevole riduzione dei costi.
Un ulteriore vantaggio della virtualizzazione si rivela nel caso di \textit{\gls{disaster recovery}}, dove l'intero sistema operativo \textit{guest} può essere facilmente ripristinato su un altro server, indipendentemente dall'\textit{hardware}, riducendo così notevolmente i tempi di indisponibilità di servizio (\textit{downtime}) in caso di guasto favorendo una maggior facile e rapida procedura di data \textit{\gls{recovery}}.
Esistono diversi tipi di virtualizzazione: \textbf{\textit{native}} e \textbf{\textit{hosted}}.
Una virtualizzazione di tipo \textbf{native} si appoggia direttamente all'\textit{hardware} \textit{host}, controllandolo direttamente per garantire tutte le funzionalità della virtualizzazione, come ad esempio \textbf{\gls{Hyper-V}} della Microsoft\footcite{questa funzionalita' e' presente solamente nelle versioni Pro e Server di Windows 10} oppure l'applicativo \textbf{\gls{Xen}} ampiamente utilizzato anche nell'ambiente Cloud di Amazon.
La virtualizzazione di tipo \textbf{hosted} è invece in esecuzione sul sistema operativo \textit{host} senza alcuna interfaccia diretta con l'hardware del computer. Questo tipo di virtualizzazione è molto diffusa, in quanto permette di accedere, in una maniera semplice ed immediata, al sistema operativo \textit{host} e \textit{guest} in maniera simultanea. Gli applicativi più usati in ambito enterprise che usano un tipo di virtualizzazione \textit{hosted} sono, ad esempio, \textit{VMware} o \textit{VirtualBox}.\\
Nella seguente figura è rappresentato un sistema operativo Windows 10 pro virtualizzato con in esecuzione il browser web "Firefox" in virtualizzazione \textit{native} tramite software Hyper-V:
%TODO: Esempio di Windows 10 Pro virtualizzato tramite Hyper-V
Di seguito, un esempio di sistema operativo Windows 10 Pro virtualizzato con in esecuzione il browser web "Firefox" in virtualizzazione \textit{hosted} tramite le due soluzioni software appena descritte:
%\begin{figure}[h!]
%    \includegraphics[width=1\textwidth]{./immagini/screenshot/firefox_virtualbox.png}
%    \caption{Applicativo "Firefox" in esecuzione sul programma di virtualizzazione "VirtualBox"}
%\end{figure}
Nello screenshot sottostante, invece, l'applicativo "Firefox" è eseguito tramite il programma di virtualizzazione "VMware":
%\begin{figure}[h!]
%    \includegraphics[width=1\textwidth]{./immagini/screenshot/firefox_vmware.png}
%    \caption{Applicativo "Firefox" in esecuzione sul programma di virtualizzazione "VMware"}
%\end{figure}
%TODO: Esempio di schermata di VMware e VirtualBox con, in esecuzione, Windows 10


Al fine di permettere al sistema operativo \textit{host} la virtualizzazione di uno o più sistemi operativi, è necessario installare un \textit{\gls{hypervisor}}\footcite{installabile solamente se il processore supporta la virtualizzazione e se quest'ultima e' abilitata da BIOS}, \textit{native} o \textit{hosted}, ovvero uno strato software che si interfacci e gestisca tutte le istanze di macchine virtuali in esecuzione sulla macchina locale. \\
La virtualizzazione non è priva di svantaggi. Il primo tra tutti, è appunto la necessità di dover \textit{virtualizzare} un intero sistema operativo al fine di eseguire l'applicativo virtuale desiderato.
Questo vincolo obbligatorio implica un consumo di memoria \gls{RAM} e di \gls{storage} non indifferente anche solo per eseguire il singolo sistema operativo virtualizzato senza alcuna applicazione virtuale in esecuzione.
Ne consegue quindi, che un'architettura a macchine virtuali avrà bisogno di uno spazio di \textit{storage} e di un quantitativo di memoria \textit{RAM}\footcite{il tipo di RAM "ECC" risulta preferibile ma non obbligatorio} installata sul server non indifferente. Anche in termini di consumo \textit{\gls{CPU}}, la virtualizzazione di molteplici sistemi operativi con le relative applicazioni virtualizzate in esecuzione può comportare grossi carichi prestazionali al server fisico, in quanto la CPU dell'host dovrà servire ed eseguire ogni sistema operativo di ogni istanza di virtualizzazione.\\
Dal punto di vista della sicurezza, quando si virtualizza un sistema operativo, sia nella virtualizzazione \textit{native} che \textit{hosted}, alcuni registri CPU sono direttamente esposti alla macchina virtuale come, ad esempio, i registri \textbf{VT-x} e \textbf{VT-d} del processore\footcite{e' necessario abilitare le estensioni di virtualizzazione da BIOS della scheda madre.} \footcite{nel caso di architettura avente processori Intel, IOMMU per architetture basate su processori AMD.}. Questi registri permettono al processore di non rendere accessibile la totalità dei suoi registri all'hypervisor e di controllare le chiamate dirette al \textit{\gls{DMA}} da parte delle soluzioni software virtualizzate.\\
Relativamente alla condivisione della rete tra macchine virtuali e host fisico, nel caso in cui si fosse installato un commutatore di rete virtuale di tipo \textbf{\gls{NAT}}, la scheda di rete dell'host e il relativo traffico sarebbe esposta a tutto il set applicativo virtualizzato e viceversa, con conseguente mancante isolamento tra macchine virtuali stesse ed host fisico. Ne conseguirebbe quindi, che eventuali condivisioni di rete, o connessioni applicative, sarebbero disponibili a tutto il set di macchine virtuali. Una possibile soluzione a questo problema potrebbe essere il passaggio da commutatore virtuale \textit{NAT} ad un tipo di commutatore virtuale che riesca ad isolare le singole macchine virtuali tra di esse e l'host fisico, anche, nel caso più estremo, assegnando ad ogni macchina virtuale una propria scheda di rete ed una propria \textit{\gls{VLAN}} di rete dedicata\footcite{per creare o impostare una VLAN, fare riferimento al router/firewall o allo switch di rete}.\\
Virtualizzare un intero sistema operativo implica, come abbiamo appena analizzato, un elevato consumo di risorse fisiche, specialmente nel caso in cui, per esigenze lavorative, si debba ricorrere ad una multipla virtualizzazione di sistemi operativi dove, in ognuno, viene eseguita una specifica applicazione che deve essere accessibile ad altri \textit{client}.
Uno dei principali aspetti positivi di un'architettura a container sta proprio nel poter virtualizzare (o \textit{containerizzare} nel caso appunto di container) una singola e specifica applicazione senza la necessità di inglobare un intero sistema operativo nell'immagine virtuale. L'esecuzione dell'applicativo, nonostante appunto la mancanza di un sistema operativo, sarà comunque possibile grazie a chiamate di sistema al kernel del s.o. host. Ne consegue quindi, che il container applicativo risultante di un'applicazione \textit{containerizzata} è di gran lunga di dimensione inferiore rispetto all' immagine\footcite{inteso come dimensione in Gb del virtual disk image (*.vdi) dell'immagine virtualizzata} della stessa applicazione \textit{virtualizzata}, causa appunto, in primis, mancanza di sistema operativo.\\
Un container è quindi una singola unità atomica contenente l'applicativo (il programma \textit{containerizzato}) con i relativi file atti alla sua corretta esecuzione senza l'immagine di un sistema operativo completo.
Al momento dell'esecuzione del container, l'applicazione \textit{containerizzata} verrà eseguita immediatamente sopra lo stato del sistema operativo host, attraverso l'aiuto del Docker Engine, senza alcun hypervisor come, ad esempio, nel caso dell'architettura a macchine virtuali. Una rappresentazione grafica del concetto appena descritto è data dalla seguente immagine:
%TODO: immagine a layer raffgurante container vs virtual machine.
Un'architettura a \textbf{container} infatti, a differenza dell'architettura a macchine virtuali, garantisce un'esecuzione separata e protetta di ogni singolo applicativo compatibile con il sistema operativo host, indipendentemente dal numero di container presenti nel sistema o dal tipo di interfaccia di rete. E' possibile, inoltre, far coesistere multipli container di uno stesso applicativo in esecuzione nello stesso momento (anche sfruttando il \textit{load-balancing}, come si accennerà nel corso di questa tesi) assegnandoci, esattamente come con le macchine virtuali, eventuali indirizzi IP statici, CPU limit e disk quota.
Essendo un container una \textbf{\gls{sandbox}} applicativa indipendente dal sistema operativo, i dati generati dalla sua esecuzione sono destinati a scomparire nell'eventualità in cui il container venisse distrutto. Per ovviare a questo problema, si può ricorrere ad una tecnica di volume-mapping, ovvero una tecnica che permette di esporre il \textbf{\gls{filesystem}} interno al container permettendone quindi la lettura e scrittura direttamente da parte dell'host. La tecnica appena accennata sarà trattata in maniera più approfondita nel corso della lettura di questa tesi.
Godendo i container di un approccio standardizzato per la loro costruzione ed esecuzione, è quindi di facile intuizione la facilità di \textit{portabilità} di questi. Un container, infatti, può essere distribuito su una nuova piattaforma in maniera estremamente veloce e senza alcuna modifica allo stesso. Ne consegue, che un eventuale rilascio e distribuzione di un applicativo interno ad un container può essere molto velicizzato rispetto alla stessa operazione svolta invece su un'architettura virtuale. Relativamente sempre allo sviluppo e distribuzione di un applicativo, tramite container è possibile un controllo di versione dell'applicativo stesso più flessibile: è possibile infatti gestire le versioni del codice con le relative dipendenze inglobando il tutto in un container, formando quindi un' unità atomica di più facile manutenzione e distribuzione.
Un altro dei vantaggi decisivi di un'architettura a container è la sua facilità di gestione. L'avvio, rimozione o la duplica dei container è un'operazione relativamente meno onerosa rispetto alla controparte nelle macchine virtuali (basti solo pensare al tempo di \textit{\gls{boot}} del sistema operativo), e può essere facilmente automatizzata e gestita dal Docker Engine. Ne consegue quindi che la scalabilità, ovvero la facilità di modifica dell'infrastruttura per far fronte alle variazioni di mole di informazioni trattate o carichi di lavoro, risulta di gestione più semplice anche per la figura sistemistica interna all'azienda.
\\
La presente immagine ritrae l'applicativo "Firefox" in esecuzione all'interno di un container esposto all'host nella porta 5800:
%\begin{figure}[h!]
%    \includegraphics[width=1\textwidth]{./immagini/screenshot/firefox_container.png}
%    \caption{Applicativo "Firefox" in esecuzione su un container all'interno del browser web "Chrome"}
%\end{figure}
%TODO: come si ottiene un container (immagine s.o. + applicazione) vs come si ottiene lo stesso con una macchina virtuale.

\section{Analisi di Docker: architettura e funzionalità}



\section{Creazione di container vs creazione di VM}

La creazione di una VM è possibile tramite apposito \textit{hypervisor}. Tuttavia, al momento della creazione, l'utente deve essere a conoscenza della quantità massima di risorse \textit{hardware} da destinare alla stessa. Questa stima, oltre ad includere il costo\footcite{inteso come quantitativo di risorse fisiche da allocare} richiesto dal programma da virtualizzare che si andrà ad installare all'interno della VM, deve includere anche il costo, almeno soddisfacente i requisiti minimi, relativo al sistema operativo. 
La seguente schermata rappresenta la creazione della macchina virtuale con 8Gb di RAM e 80Gb di disco rigido dedicati:\\
%TODO: immagine di avvio dell'installazione di Windows 10 Pro da VMWARE
Terminata la fase di analisi dei costi, sarà necessario installare manualmente il sistema operativo all'interno della macchina virtuale appena creata. Per fare ciò, bisognerà avviare la macchina virtuale da un supporto di \textbf{boot}, come ad esempio una immagine \gls{ISO} di un sistema operativo, avviabile.
Successivamente alla fase di avvio di installazione della VM, si passerà alla fase vera e propria di installazione del sistema operativo, riassunta nelle seguenti immagini:
%TODO: immagini dell'installazione del sistema operativo nella VM con VMWARE.
Una volta ottenuto un sistema operativo funzionante ed avviabile, per ottimizzarne al meglio le prestazioni, tramite ad esempio installazione dei relativi \gls{driver} video virtuali, ed espanderne le funzionalità, come la possibilità di accedere a volume-mapping condivisi con il sistema operativo host, è necessario installare le relative \textbf{\gls{guest additions}}.
%TODO: immagine raffigurante l'installazione delle Guest Additions su VMWARE.
Una volta fatti i passi sopra-descritti, si avrà un sistema operativo virtualizzato completamente funzionante, pronto per l'installazione di tutto il software applicativo desiderato.
%TODO: immagine raffigurante W10 Pro avviato e funzionante con Firefox in esecuzione.
\\
Come precedentemente affermato, un container è un'unità atomica costituita principalmente da una o più applicazioni e dalle librerie di sistema operativo atte al loro corretto funzionamento.
Al fine di poter generare ed utilizzare correttamente un container, è necessario prima costruirne il relativo \textbf{\gls{dockerfile}}.
Un \textbf{dockerfile} è un documento di testo, senza alcuna estensione, contenente una serie di passi ed istruzioni atti alla corretta creazione di una immagine di un applicativo. Il Docker Daemon, per costruire correttamente un'immagine, leggerà ed eseguirà in maniera sequenziale ogni comando trascritto all'interno del dockerfile. Al termine della lettura del dockerfile, si avrà quindi un'immagine eseguibile di un applicativo. Un \textbf{container} è un'istanza di esecuzione di una immagine, a cui è attribuito un nome, arbitrario, dal Docker Daemon.
Le seguenti immagini mostrano i corretti passi per la costruzione di un container con, all'interno, l'applicativo "Firefox":
%TODO: immagini raffiguranti i passi e comandi atti alla creazione di un container
La creazione di multipli container cloni, ovvero container generati da una singola immagine, è un'operazione di semplice e veloce esecuzione, in quanto il Docker Engine, durante la costruzione di ogni container, adotta un meccanismo di \textit{\gls{caching}} dei vari \textit{\gls{layer}} di cui un container è composto. Questo meccanismo permette quindi una costruzione, o aggiornamento, di un container molto più veloce rispetto ad una sua completa ri-creazione, in quanto si useranno, se compatibili, i layer in cache già precedentemente costruiti al fine di costruire il nuovo container contenente l'applicativo, nuovo o aggiornato, desiderato.



